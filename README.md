# kv-parallax
Parallax library that offers CSS variables useful for style-based effects.




@summary
Parallax library that offers CSS variables useful for style-based effects.

@description
Provides a set of normalised css variables to any element with the class 
"css-parallax".

All values generated by parallax are normalised to between -1 and 1, and are
unitless. Use these variables in CSS with the "calc" function and multiply
them with some desired unit. For example; multiply "--parallax-coverage-y" 
with "100%" and you'll have the percentage of the element visible on-screen
for that axis.

Use CSS min() and max() for clamping. By clamping the --parallax-scroll 
values via min(0, var(--parallax-scroll)) you can safely ensure some effects 
only take place on "entry" or "exit".

It is strongly reccomended you use CSS math functions as much as possible
using this library, in lieu of javascript. The vast majority of parallax
effects seen on the web today are possible using CSS variables provided.

To use this library include it on your site and call kvParallax.init({}); 
once the dom is loaded.
You may populate init with the following options:
    className: default 'css-parallax'. Elements with this class are tracked.
    cssPrefix: default 'parallax-'. The prefix used for CSS variables.
    decimalAccuracy: default 3. Values of 2 or lower result in jitter.

@var --parallax-scroll-[x|y]
@return -1 to 1
Returns the "progress" of the element on screen. If you use something like
calc(100%var(--parallax-scroll-y)) you'll get the percentage offset for
simple background parallaxing.
Minimum is -1; when the 'start' of an element is first entering viewport from
either the bottom or right..
At 0 the center of the element is on the center of the screen.
Maximum is 1; when the 'end' of an element is leaving the viewport.

@var --parallax-cubic-[x|y]
@return -1 to 1
Similar to the parallax scroll functions, but instead of being strictly
linear in progession a cubic function is applied. Great when you want 
something to move in and out with a bit more "oomph".

@var --parallax-coverage-[x|y]
@return 0 to 1
If multiplied by 100, this becomes the percentage of the elements' visibility
on a given access.
Minimum is 0: None of the element is visible on the axis.
Maximum is 1: Either the element is completly visible, or covers the axis.

@var --parallax-visible
@return 0 OR 1
@note This explicity returns only 0 or 1.
Use this if you want to target children extending beyond the edge of a 
tracked element. Using this in tandem with transitions is optimal.
Value of 0: The element is not currently on screen.
Value of 1: Any amount of the element is on screen.

@var --parallax-half-visible, --parallax-quarter-visible
@return 0 OR 1
@note This explicity returns only 0 or 1. 
Same as --parallax-visible, but requires at least quarter or half of a
tracked element to be visible before returning 1. These are designed to be 
used  in tandem with a CSS transition.
Value of 0: Not enough of hte element is on screen.
Value of 1: Enough of the element is on screen.

@method addCssVariable
@param name string
@param callback callback
Adds a new CSS variable to the values generated by kvParallax. The name will 
be given the prefix "--parallax-". The callback accepts two parameters.
The first is an "event" object containing "xScrollProgress", 
"yScrollProgress", "xCoverage", and "yCoverage". The second is the DomNode 
being updated.
@note If the element is off-screen kvParallax will NOT process any callbacks.
Parallax effects should contain themselves to within the tracked element.

@example
This will generate a value that will make a parallax "wave" 3 times.
// Javascript
kvParallax.addCssVariable('wavy-effect', (e, el) => {
    return Math.sin(Math.PIe.yScrollProgress3);
});
// CSS
left: calc(100pxvar(--parallax-my-wavy-effect));

@access kvParallaxData
If you're looking to use the parallax values in script, tracked elements will
have access to the expando property "kvParallaxData". It has four values
including "xScrollProgress", "yScrollProgress", "xCoverage", and "yCoverage".
Using these values in conjunction with requestAnimationFrame calls you can
apply specialty logic.
In general the only real reason to use this is if you're drawing complex
scenes (possibly using 3D) for your parallax effects, or using video and are
using scroll positions to determine the video time position.
 */
